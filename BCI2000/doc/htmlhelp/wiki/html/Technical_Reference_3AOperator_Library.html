<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" >
<head>
<title>Technical Reference:Operator Library - BCI2000 Help</title>
<meta http-equiv="Content-type" content="text/html; charset=utf-8" />
<meta name="keywords" content="Technical Reference:Operator Library,Programming Reference:Debug Output,Technical Reference:Core Modules,Technical Reference:States of Operation,Technical Reference:Visualization Properties,User Reference:Operator Module,User Reference:Operator Module Scripting" />
<link rel="shortcut icon" href="../../favicon.ico" />
<link rel='stylesheet' type='text/css' media='print' href='../skins/common/wikiprintable.css' />
<link rel="stylesheet" href="../skins/common/wikistandard.css@1" type="text/css" />
<link rel="stylesheet" href="../skins/common/common.css" type="text/css" />
<link rel="stylesheet" href="../skins/common/htmlhelp.css" type="text/css" />

<style type='text/css'>
a.new, #quickbar a.new { color: #CC2200; }
.editsection { display: none; }
#quickbar { position: absolute; top: 4px; left: 4px;  }
#article { margin-left: 152px; margin-right: 4px; }
</style>
</head>

<body bgcolor='#FFFFFF'>

<div id='content'>
<div id='topbar'>
<table border='0' cellspacing='0' width='98%'>
<tr>
</tr>
</table>
</div>

<div id='article'>
<h1 class="pagetitle">Operator Library</h1><p class="subtitle">Technical Reference</p><hr class="sep" /><p>The Operator Library is a shared library that encapsulates the Operator Module's core functionality into an interface that allows to embed Operator functionality into one's own application. This way, is is possible to write your own Operator module, or to control BCI2000 from your own application, without having to deal with details of the BCI2000 protocol. The BCI2000 Operator library can be used from any programming language that allows using a shared library (DLL). Although the Operator library is written in C++, its DLL interface is plain C, and can be used with compiled languages such as C, C++, C#, Pascal, but also with interpreted languages that can call functions in a DLL, such as Python, Matlab, VisualBasic, etc. Interfacing with Java requires a JNI (Java Native Interface) wrapper, which is currently not provided by BCI2000. 
</p><p>For a C++ example that uses the Operator Library to implement a simple Operator Module, see <a href="http://www.bci2000.org/tracproj/browser/trunk/src/contrib/OperatorLibApplications/OperatorLibDemo/main.cpp" class='external text' title="http://www.bci2000.org/tracproj/browser/trunk/src/contrib/OperatorLibApplications/OperatorLibDemo/main.cpp" rel="nofollow">the OperatorLibDemo</a> program.
</p>
<table id="toc" class="toc" summary="Contents"><tr><td><div id="toctitle"><h2>Contents</h2></div>
<ul>
<li class='toclevel-1'><a href="Technical_Reference%253AOperator_Library.html#System_State_.28State_of_Operation.29"><span class="tocnumber">1</span> <span class="toctext">System State (State of Operation)</span></a>
<ul>
<li class='toclevel-2'><a href="Technical_Reference%253AOperator_Library.html#BCI_StateUnavailable"><span class="tocnumber">1.1</span> <span class="toctext">BCI_StateUnavailable</span></a></li>
<li class='toclevel-2'><a href="Technical_Reference%253AOperator_Library.html#BCI_StateIdle"><span class="tocnumber">1.2</span> <span class="toctext">BCI_StateIdle</span></a></li>
<li class='toclevel-2'><a href="Technical_Reference%253AOperator_Library.html#BCI_StateStartup"><span class="tocnumber">1.3</span> <span class="toctext">BCI_StateStartup</span></a></li>
<li class='toclevel-2'><a href="Technical_Reference%253AOperator_Library.html#BCI_StateInitialization"><span class="tocnumber">1.4</span> <span class="toctext">BCI_StateInitialization</span></a></li>
<li class='toclevel-2'><a href="Technical_Reference%253AOperator_Library.html#BCI_StateResting"><span class="tocnumber">1.5</span> <span class="toctext">BCI_StateResting</span></a></li>
<li class='toclevel-2'><a href="Technical_Reference%253AOperator_Library.html#BCI_StateSuspended"><span class="tocnumber">1.6</span> <span class="toctext">BCI_StateSuspended</span></a></li>
<li class='toclevel-2'><a href="Technical_Reference%253AOperator_Library.html#BCI_StateParamsModified"><span class="tocnumber">1.7</span> <span class="toctext">BCI_StateParamsModified</span></a></li>
<li class='toclevel-2'><a href="Technical_Reference%253AOperator_Library.html#BCI_StateRunning"><span class="tocnumber">1.8</span> <span class="toctext">BCI_StateRunning</span></a></li>
<li class='toclevel-2'><a href="Technical_Reference%253AOperator_Library.html#BCI_StateTermination"><span class="tocnumber">1.9</span> <span class="toctext">BCI_StateTermination</span></a></li>
<li class='toclevel-2'><a href="Technical_Reference%253AOperator_Library.html#BCI_StateBusy"><span class="tocnumber">1.10</span> <span class="toctext">BCI_StateBusy</span></a></li>
<li class='toclevel-2'><a href="Technical_Reference%253AOperator_Library.html#int_BCI_GetStateOfOperation.28.29"><span class="tocnumber">1.11</span> <span class="toctext">int BCI_GetStateOfOperation()</span></a></li>
<li class='toclevel-2'><a href="Technical_Reference%253AOperator_Library.html#int_BCI_SetConfig.28.29"><span class="tocnumber">1.12</span> <span class="toctext">int BCI_SetConfig()</span></a></li>
<li class='toclevel-2'><a href="Technical_Reference%253AOperator_Library.html#int_BCI_StartRun.28.29"><span class="tocnumber">1.13</span> <span class="toctext">int BCI_StartRun()</span></a></li>
<li class='toclevel-2'><a href="Technical_Reference%253AOperator_Library.html#int_BCI_StopRun.28.29"><span class="tocnumber">1.14</span> <span class="toctext">int BCI_StopRun()</span></a></li>
</ul>
</li>
<li class='toclevel-1'><a href="Technical_Reference%253AOperator_Library.html#Parameterization"><span class="tocnumber">2</span> <span class="toctext">Parameterization</span></a>
<ul>
<li class='toclevel-2'><a href="Technical_Reference%253AOperator_Library.html#int_BCI_PutParameter.28_const_char.2A_parameterLine_.29"><span class="tocnumber">2.1</span> <span class="toctext">int BCI_PutParameter( const char* parameterLine )</span></a></li>
<li class='toclevel-2'><a href="Technical_Reference%253AOperator_Library.html#const_char.2A_BCI_GetParameter.28_long_index_.29"><span class="tocnumber">2.2</span> <span class="toctext">const char* BCI_GetParameter( long index )</span></a></li>
<li class='toclevel-2'><a href="Technical_Reference%253AOperator_Library.html#int_BCI_PutState.28_const_char.2A_stateLine_.29"><span class="tocnumber">2.3</span> <span class="toctext">int BCI_PutState( const char* stateLine )</span></a></li>
<li class='toclevel-2'><a href="Technical_Reference%253AOperator_Library.html#const_char.2A_BCI_GetState.28_long_index_.29"><span class="tocnumber">2.4</span> <span class="toctext">const char* BCI_GetState( long index )</span></a></li>
<li class='toclevel-2'><a href="Technical_Reference%253AOperator_Library.html#int_BCI_PutEvent.28_const_char.2A_eventLine_.29"><span class="tocnumber">2.5</span> <span class="toctext">int BCI_PutEvent( const char* eventLine )</span></a></li>
<li class='toclevel-2'><a href="Technical_Reference%253AOperator_Library.html#const_char.2A_BCI_GetEvent.28_long_index_.29"><span class="tocnumber">2.6</span> <span class="toctext">const char* BCI_GetEvent( long index )</span></a></li>
<li class='toclevel-2'><a href="Technical_Reference%253AOperator_Library.html#int_BCI_PutVisProperty.28_const_char.2A_visID.2C_int_cfgID.2C_const_char.2A_value_.29"><span class="tocnumber">2.7</span> <span class="toctext">int BCI_PutVisProperty( const char* visID, int cfgID, const char* value )</span></a></li>
<li class='toclevel-2'><a href="Technical_Reference%253AOperator_Library.html#const_char.2A_BCI_GetVisProperty.28_const_char.2A_visID.2C_int_cfgID_.29"><span class="tocnumber">2.8</span> <span class="toctext">const char* BCI_GetVisProperty( const char* visID, int cfgID )</span></a></li>
</ul>
</li>
<li class='toclevel-1'><a href="Technical_Reference%253AOperator_Library.html#Online_Information"><span class="tocnumber">3</span> <span class="toctext">Online Information</span></a>
<ul>
<li class='toclevel-2'><a href="Technical_Reference%253AOperator_Library.html#int_BCI_SetStateValue.28_const_char.2A_stateName.2C_long_value_.29"><span class="tocnumber">3.1</span> <span class="toctext">int BCI_SetStateValue( const char* stateName, long value )</span></a></li>
<li class='toclevel-2'><a href="Technical_Reference%253AOperator_Library.html#long_BCI_GetStateValue.28_const_char.2A_stateName_.29"><span class="tocnumber">3.2</span> <span class="toctext">long BCI_GetStateValue( const char* stateName )</span></a></li>
<li class='toclevel-2'><a href="Technical_Reference%253AOperator_Library.html#int_BCI_SetEvent.28_const_char.2A_eventName.2C_long_value_.29"><span class="tocnumber">3.3</span> <span class="toctext">int BCI_SetEvent( const char* eventName, long value )</span></a></li>
<li class='toclevel-2'><a href="Technical_Reference%253AOperator_Library.html#int_BCI_GetSignalChannels.28.29"><span class="tocnumber">3.4</span> <span class="toctext">int BCI_GetSignalChannels()</span></a></li>
<li class='toclevel-2'><a href="Technical_Reference%253AOperator_Library.html#int_BCI_GetSignalElements.28.29"><span class="tocnumber">3.5</span> <span class="toctext">int BCI_GetSignalElements()</span></a></li>
<li class='toclevel-2'><a href="Technical_Reference%253AOperator_Library.html#float_BCI_GetSignal.28_int_channel.2C_int_element_.29"><span class="tocnumber">3.6</span> <span class="toctext">float BCI_GetSignal( int channel, int element )</span></a></li>
</ul>
</li>
<li class='toclevel-1'><a href="Technical_Reference%253AOperator_Library.html#Callbacks"><span class="tocnumber">4</span> <span class="toctext">Callbacks</span></a>
<ul>
<li class='toclevel-2'><a href="Technical_Reference%253AOperator_Library.html#Callback_Constants"><span class="tocnumber">4.1</span> <span class="toctext">Callback Constants</span></a></li>
<li class='toclevel-2'><a href="Technical_Reference%253AOperator_Library.html#BCI_OnSystemStateChange.28_void.2A_refdata_.29"><span class="tocnumber">4.2</span> <span class="toctext">BCI_OnSystemStateChange( void* refdata )</span></a></li>
<li class='toclevel-2'><a href="Technical_Reference%253AOperator_Library.html#BCI_OnCoreInput.28_void.2A_refdata_.29"><span class="tocnumber">4.3</span> <span class="toctext">BCI_OnCoreInput( void* refdata )</span></a></li>
<li class='toclevel-2'><a href="Technical_Reference%253AOperator_Library.html#BCI_OnConnect.28_void.2A_refdata_.29"><span class="tocnumber">4.4</span> <span class="toctext">BCI_OnConnect( void* refdata )</span></a></li>
<li class='toclevel-2'><a href="Technical_Reference%253AOperator_Library.html#BCI_OnSetConfig.28_void.2A_refdata_.29"><span class="tocnumber">4.5</span> <span class="toctext">BCI_OnSetConfig( void* refdata )</span></a></li>
<li class='toclevel-2'><a href="Technical_Reference%253AOperator_Library.html#BCI_OnStart.28_void.2A_refdata_.29"><span class="tocnumber">4.6</span> <span class="toctext">BCI_OnStart( void* refdata )</span></a></li>
<li class='toclevel-2'><a href="Technical_Reference%253AOperator_Library.html#BCI_OnSuspend.28_void.2A_refdata_.29"><span class="tocnumber">4.7</span> <span class="toctext">BCI_OnSuspend( void* refdata )</span></a></li>
<li class='toclevel-2'><a href="Technical_Reference%253AOperator_Library.html#BCI_OnResume.28_void.2A_refdata_.29"><span class="tocnumber">4.8</span> <span class="toctext">BCI_OnResume( void* refdata )</span></a></li>
<li class='toclevel-2'><a href="Technical_Reference%253AOperator_Library.html#BCI_OnShutdown.28_void.2A_refdata_.29"><span class="tocnumber">4.9</span> <span class="toctext">BCI_OnShutdown( void* refdata )</span></a></li>
<li class='toclevel-2'><a href="Technical_Reference%253AOperator_Library.html#BCI_OnQuitRequest.28_void.2A_refdata.2C_const_char.2A.2A_pMsg_.29"><span class="tocnumber">4.10</span> <span class="toctext">BCI_OnQuitRequest( void* refdata, const char** pMsg )</span></a></li>
<li class='toclevel-2'><a href="Technical_Reference%253AOperator_Library.html#BCI_OnLogMessage.28_void.2A_refdata.2C_const_char.2A_msg_.29"><span class="tocnumber">4.11</span> <span class="toctext">BCI_OnLogMessage( void* refdata, const char* msg )</span></a></li>
<li class='toclevel-2'><a href="Technical_Reference%253AOperator_Library.html#BCI_OnWarningMessage.28_void.2A_refdata.2C_const_char.2A_msg_.29"><span class="tocnumber">4.12</span> <span class="toctext">BCI_OnWarningMessage( void* refdata, const char* msg )</span></a></li>
<li class='toclevel-2'><a href="Technical_Reference%253AOperator_Library.html#BCI_OnErrorMessage.28_void.2A_refdata.2C_const_char.2A_msg_.29"><span class="tocnumber">4.13</span> <span class="toctext">BCI_OnErrorMessage( void* refdata, const char* msg )</span></a></li>
<li class='toclevel-2'><a href="Technical_Reference%253AOperator_Library.html#BCI_OnDebugMessage.28_void.2A_refdata.2C_const_char.2A_msg_.29"><span class="tocnumber">4.14</span> <span class="toctext">BCI_OnDebugMessage( void* refdata, const char* msg )</span></a></li>
<li class='toclevel-2'><a href="Technical_Reference%253AOperator_Library.html#BCI_OnParameter.28_void.2A_refdata.2C_const_char.2A_parameterline_.29"><span class="tocnumber">4.15</span> <span class="toctext">BCI_OnParameter( void* refdata, const char* parameterline )</span></a></li>
<li class='toclevel-2'><a href="Technical_Reference%253AOperator_Library.html#BCI_OnState.28_void.2A_refdata.2C_const_char.2A_stateline_.29"><span class="tocnumber">4.16</span> <span class="toctext">BCI_OnState( void* refdata, const char* stateline )</span></a></li>
<li class='toclevel-2'><a href="Technical_Reference%253AOperator_Library.html#BCI_OnVisPropertyMessage.28_void.2A_refdata.2C_const_char.2A_visID.2C_int_cfgID.2C_const_char.2A_value_.29"><span class="tocnumber">4.17</span> <span class="toctext">BCI_OnVisPropertyMessage( void* refdata, const char* visID, int cfgID, const char* value )</span></a></li>
<li class='toclevel-2'><a href="Technical_Reference%253AOperator_Library.html#BCI_OnVisProperty.28_void.2A_refdata.2C_const_char.2A_visID.2C_int_cfgID.2C_const_char.2A_value_.29"><span class="tocnumber">4.18</span> <span class="toctext">BCI_OnVisProperty( void* refdata, const char* visID, int cfgID, const char* value )</span></a></li>
<li class='toclevel-2'><a href="Technical_Reference%253AOperator_Library.html#BCI_OnInitializeVis.28_void.2A_refdata.2C_const_char.2A_visID.2C_const_char.2A_kind_.29"><span class="tocnumber">4.19</span> <span class="toctext">BCI_OnInitializeVis( void* refdata, const char* visID, const char* kind )</span></a></li>
<li class='toclevel-2'><a href="Technical_Reference%253AOperator_Library.html#BCI_OnVisMemo.28_void.2A_refdata.2C_const_char.2A_visID.2C_const_char.2A_msg_.29"><span class="tocnumber">4.20</span> <span class="toctext">BCI_OnVisMemo( void* refdata, const char* visID, const char* msg )</span></a></li>
<li class='toclevel-2'><a href="Technical_Reference%253AOperator_Library.html#BCI_OnVisSignal.28_void.2A_refdata.2C_const_char.2A_visID.2C_int_channels.2C_int_elements.2C_float.2A_data_.29"><span class="tocnumber">4.21</span> <span class="toctext">BCI_OnVisSignal( void* refdata, const char* visID, int channels, int elements, float* data )</span></a></li>
<li class='toclevel-2'><a href="Technical_Reference%253AOperator_Library.html#BCI_OnVisBitmap.28_void.2A_refdata.2C_const_char.2A_visID.2C_int_width.2C_int_height.2C_unsigned_short.2A_data_.29"><span class="tocnumber">4.22</span> <span class="toctext">BCI_OnVisBitmap( void* refdata, const char* visID, int width, int height, unsigned short* data )</span></a></li>
<li class='toclevel-2'><a href="Technical_Reference%253AOperator_Library.html#int_BCI_OnUnknownCommand.28_void.2A_refdata.2C_const_char.2A_command_.29"><span class="tocnumber">4.23</span> <span class="toctext">int BCI_OnUnknownCommand( void* refdata, const char* command )</span></a></li>
<li class='toclevel-2'><a href="Technical_Reference%253AOperator_Library.html#BCI_OnScriptHelp.28_void.2A_refdata.2C_const_char.2A.2A_pMsg_.29"><span class="tocnumber">4.24</span> <span class="toctext">BCI_OnScriptHelp( void* refdata, const char** pMsg )</span></a></li>
<li class='toclevel-2'><a href="Technical_Reference%253AOperator_Library.html#BCI_OnScriptError.28_void.2A_refdata.2C_const_char.2A_msg_.29"><span class="tocnumber">4.25</span> <span class="toctext">BCI_OnScriptError( void* refdata, const char* msg )</span></a></li>
</ul>
</li>
<li class='toclevel-1'><a href="Technical_Reference%253AOperator_Library.html#Functions_that_manage_callbacks"><span class="tocnumber">5</span> <span class="toctext">Functions that manage callbacks</span></a>
<ul>
<li class='toclevel-2'><a href="Technical_Reference%253AOperator_Library.html#int_BCI_SetCallback.28_long.2C_BCI_Function.2C_void.2A_.29"><span class="tocnumber">5.1</span> <span class="toctext">int BCI_SetCallback( long, BCI_Function, void* )</span></a></li>
<li class='toclevel-2'><a href="Technical_Reference%253AOperator_Library.html#int_BCI_SetExternalCallback.28_long.2C_BCI_Function.2C_void.2A_.29"><span class="tocnumber">5.2</span> <span class="toctext">int BCI_SetExternalCallback( long, BCI_Function, void* )</span></a></li>
<li class='toclevel-2'><a href="Technical_Reference%253AOperator_Library.html#int_BCI_CheckPendingCallback.28.29"><span class="tocnumber">5.3</span> <span class="toctext">int BCI_CheckPendingCallback()</span></a></li>
<li class='toclevel-2'><a href="Technical_Reference%253AOperator_Library.html#BCI_Function_BCI_GetCallbackFunction.28_long_.29"><span class="tocnumber">5.4</span> <span class="toctext">BCI_Function BCI_GetCallbackFunction( long )</span></a></li>
<li class='toclevel-2'><a href="Technical_Reference%253AOperator_Library.html#void.2A_BCI_GetCallbackData.28_long_.29"><span class="tocnumber">5.5</span> <span class="toctext">void* BCI_GetCallbackData( long )</span></a></li>
<li class='toclevel-2'><a href="Technical_Reference%253AOperator_Library.html#int_BCI_GetCallbackIsExternal.28_long_.29"><span class="tocnumber">5.6</span> <span class="toctext">int BCI_GetCallbackIsExternal( long )</span></a></li>
</ul>
</li>
<li class='toclevel-1'><a href="Technical_Reference%253AOperator_Library.html#Miscellaneous_Functions"><span class="tocnumber">6</span> <span class="toctext">Miscellaneous Functions</span></a>
<ul>
<li class='toclevel-2'><a href="Technical_Reference%253AOperator_Library.html#const_char.2A_BCI_GetInfo.28_void_.29"><span class="tocnumber">6.1</span> <span class="toctext">const char* BCI_GetInfo( void )</span></a></li>
<li class='toclevel-2'><a href="Technical_Reference%253AOperator_Library.html#const_char.2A_BCI_GetConnectionInfo.28_int_index_.29"><span class="tocnumber">6.2</span> <span class="toctext">const char* BCI_GetConnectionInfo( int index )</span></a></li>
<li class='toclevel-2'><a href="Technical_Reference%253AOperator_Library.html#const_char.2A_BCI_GetCoreModuleStatus.28_int_index_.29"><span class="tocnumber">6.3</span> <span class="toctext">const char* BCI_GetCoreModuleStatus( int index )</span></a></li>
<li class='toclevel-2'><a href="Technical_Reference%253AOperator_Library.html#int_BCI_Startup.28_const_char.2A_arguments_.29"><span class="tocnumber">6.4</span> <span class="toctext">int BCI_Startup( const char* arguments )</span></a></li>
<li class='toclevel-2'><a href="Technical_Reference%253AOperator_Library.html#int_BCI_Shutdown.28_void_.29"><span class="tocnumber">6.5</span> <span class="toctext">int BCI_Shutdown( void )</span></a></li>
<li class='toclevel-2'><a href="Technical_Reference%253AOperator_Library.html#int_BCI_Initialize.28_void_.29"><span class="tocnumber">6.6</span> <span class="toctext">int BCI_Initialize( void )</span></a></li>
<li class='toclevel-2'><a href="Technical_Reference%253AOperator_Library.html#int_BCI_Dispose.28_void_.29"><span class="tocnumber">6.7</span> <span class="toctext">int BCI_Dispose( void )</span></a></li>
<li class='toclevel-2'><a href="Technical_Reference%253AOperator_Library.html#int_BCI_TelnetListen.28_const_char.2A_address_.29"><span class="tocnumber">6.8</span> <span class="toctext">int BCI_TelnetListen( const char* address )</span></a></li>
<li class='toclevel-2'><a href="Technical_Reference%253AOperator_Library.html#int_BCI_TelnetClose.28_void_.29"><span class="tocnumber">6.9</span> <span class="toctext">int BCI_TelnetClose( void )</span></a></li>
<li class='toclevel-2'><a href="Technical_Reference%253AOperator_Library.html#int_BCI_ExecuteScript.28_const_char.2A_script_.29"><span class="tocnumber">6.10</span> <span class="toctext">int BCI_ExecuteScript( const char* script )</span></a></li>
<li class='toclevel-2'><a href="Technical_Reference%253AOperator_Library.html#const_char.2A_BCI_ExecuteScriptWithResult.28_const_char.2A_script_.29"><span class="tocnumber">6.11</span> <span class="toctext">const char* BCI_ExecuteScriptWithResult( const char* script )</span></a></li>
<li class='toclevel-2'><a href="Technical_Reference%253AOperator_Library.html#int_BCI_ReleaseObject.28_const_char.2A_.29"><span class="tocnumber">6.12</span> <span class="toctext">int BCI_ReleaseObject( const char* )</span></a></li>
</ul>
</li>
<li class='toclevel-1'><a href="Technical_Reference%253AOperator_Library.html#See_also"><span class="tocnumber">7</span> <span class="toctext">See also</span></a></li>
</ul>
</td></tr></table>
<a name="System_State_.28State_of_Operation.29"></a><h2>System State (State of Operation)</h2>
<p>BCI2000 system state may be queried using <tt>BCI_GetStateOfOperation()</tt>, and modified using the <tt>BCI_SetConfig()</tt>, <tt>BCI_StartRun()</tt>, and <tt>BCI_StopRun()</tt> functions. These functions manipulate system state in a way that is analogous to the main buttons in the standard <a href="User_Reference%253AOperator_Module.html" title="User Reference:Operator Module">Operator module</a>.
</p><p>System state is one of the following:
</p>
<a name="BCI_StateUnavailable"></a><h3>BCI_StateUnavailable</h3>
<p>The system is not available for changes to system state.
</p>
<a name="BCI_StateIdle"></a><h3>BCI_StateIdle</h3>
<p>The system is initialized, but not started up, ie., not waiting for connections.
</p>
<a name="BCI_StateStartup"></a><h3>BCI_StateStartup</h3>
<p>The Operator module is waiting for core modules to connect.
</p>
<a name="BCI_StateInitialization"></a><h3>BCI_StateInitialization</h3>
<p>Core modules are connected, the system is waiting to be parameterized via <tt>SetConfig()</tt>.
</p>
<a name="BCI_StateResting"></a><h3>BCI_StateResting</h3>
<p>The system has been parameterized and is waiting for a <tt>StartRun()</tt> command.
</p>
<a name="BCI_StateSuspended"></a><h3>BCI_StateSuspended</h3>
<p>The system has been suspended via <tt>StopRun()</tt>, or from one of the modules setting the "Running" state variable to 0.
</p>
<a name="BCI_StateParamsModified"></a><h3>BCI_StateParamsModified</h3>
<p>The system has been suspended, and parameters have been modified from one or more of the core modules.
</p>
<a name="BCI_StateRunning"></a><h3>BCI_StateRunning</h3>
<p>The system is running.
</p>
<a name="BCI_StateTermination"></a><h3>BCI_StateTermination</h3>
<p>The system is waiting for termination.
</p>
<a name="BCI_StateBusy"></a><h3>BCI_StateBusy</h3>
<p>The system is currently busy, and not in one of the above states. It is not available for changes to system state.
</p><p>System state may be manipulated calling one of the following functions:
</p>
<a name="int_BCI_GetStateOfOperation.28.29"></a><h3>int BCI_GetStateOfOperation()</h3>
<p>Determines the externally visible state of the state machine, i.e.
the state of operation of the BCI2000 system.
</p>
<a name="int_BCI_SetConfig.28.29"></a><h3>int BCI_SetConfig()</h3>
<p>Applies current parameter settings to the BCI2000 system.
</p>
<dl><dt>returns</dt><dd>   1 if successful, 0 otherwise.
</dd></dl>
<a name="int_BCI_StartRun.28.29"></a><h3>int BCI_StartRun()</h3>
<p>Starts a new run.
</p>
<dl><dt>returns</dt><dd>   1 if successful, 0 otherwise.
</dd></dl>
<a name="int_BCI_StopRun.28.29"></a><h3>int BCI_StopRun()</h3>
<p>Stops the current run.
</p>
<dl><dt>returns</dt><dd>   1 if successful, 0 otherwise.
</dd></dl>
<a name="Parameterization"></a><h2>Parameterization</h2>
<p>Parameterization functions allow to populate and modify of the Operator Library's internal parameter list, state list, event list, and visproperty list. When calling <tt>SetConfig()</tt>, parameter values are applied to the BCI2000 system.
</p>
<a name="int_BCI_PutParameter.28_const_char.2A_parameterLine_.29"></a><h3>int BCI_PutParameter( const char* parameterLine )</h3>
<p>Parses a BCI2000 parameter definition line, and adds the resulting parameter object to the internal parameter list, or changes the value of a parameter if it exists.
</p>
<dl><dt>arguments</dt><dd> Pointer to a null-terminated parameter line string.
</dd><dt>returns</dt><dd>   1 if successful, 0 otherwise.
</dd></dl>
<a name="const_char.2A_BCI_GetParameter.28_long_index_.29"></a><h3>const char* BCI_GetParameter( long index )</h3>
<p>Returns the parameter with the given index from the operator's internal parameter list, or NULL when the index is out of range.
</p>
<dl><dt>arguments</dt><dd> Parameter index.
</dd><dt>returns</dt><dd>   Pointer to a null-terminated string containing a parameter line, or NULL. The output buffer is allocated by the library, and should be released by the caller using <tt>BCI_ReleaseObject()</tt>.
</dd></dl>
<a name="int_BCI_PutState.28_const_char.2A_stateLine_.29"></a><h3>int BCI_PutState( const char* stateLine )</h3>
<p>Parses a BCI2000 state definition line, and adds the resulting state to the operator library's state list.
</p>
<dl><dt>arguments</dt><dd> Pointer to a null-terminated state line string.
</dd><dt>returns</dt><dd>   1 if successful, 0 otherwise.
</dd></dl>
<a name="const_char.2A_BCI_GetState.28_long_index_.29"></a><h3>const char* BCI_GetState( long index )</h3>
<p>Returns the state with the given index from the DLL's internal state list. , or NULL when the index is out of range.
</p>
<dl><dt>arguments</dt><dd> State index.
</dd><dt>returns</dt><dd>   Pointer to a null-terminated string containing a state line, or NULL. The output buffer is allocated by the library, and should be released by the caller using <tt>BCI_ReleaseObject()</tt>.
</dd></dl>
<a name="int_BCI_PutEvent.28_const_char.2A_eventLine_.29"></a><h3>int BCI_PutEvent( const char* eventLine )</h3>
<p>Parses a BCI2000 event definition line, and adds the resulting event to the operator library's event list.
</p>
<dl><dt>arguments</dt><dd> Pointer to a null-terminated event line string.
</dd><dt>returns</dt><dd>   1 if successful, 0 otherwise.
</dd></dl>
<a name="const_char.2A_BCI_GetEvent.28_long_index_.29"></a><h3>const char* BCI_GetEvent( long index )</h3>
<p>Returns the event with the given index from the DLL's internal event list. , or NULL when the index is out of range.
</p>
<dl><dt>arguments</dt><dd> Event index.
</dd><dt>returns</dt><dd>   Pointer to a null-terminated string containing an event line, or NULL. The output buffer is allocated by the library, and should be released by the caller using <tt>BCI_ReleaseObject()</tt>.
</dd></dl>
<a name="int_BCI_PutVisProperty.28_const_char.2A_visID.2C_int_cfgID.2C_const_char.2A_value_.29"></a><h3>int BCI_PutVisProperty( const char* visID, int cfgID, const char* value )</h3>
<p>Sets the a property to the given value, or adds the property to the property list if it is not present. A list of visualization properties is available at <a href="Technical_Reference%253AVisualization_Properties.html" title="Technical Reference:Visualization Properties">Technical Reference:Visualization Properties</a>.
</p>
<dl><dt>arguments</dt><dd> Pointer to a null-terminated vis ID string, numeric config ID, and a pointer to a null-terminated value string.
</dd><dt>returns</dt><dd>   1 if successful, 0 otherwise.
</dd></dl>
<a name="const_char.2A_BCI_GetVisProperty.28_const_char.2A_visID.2C_int_cfgID_.29"></a><h3>const char* BCI_GetVisProperty( const char* visID, int cfgID )</h3>
<p>Returns the property with the given cfgID from the DLL's internal property list. A list of visualization properties is available at <a href="Technical_Reference%253AVisualization_Properties.html" title="Technical Reference:Visualization Properties">Technical Reference:Visualization Properties</a>.
</p>
<dl><dt>arguments</dt><dd> Pointer to a null-terminated vis ID string, numeric config ID.
</dd><dt>returns</dt><dd>   Pointer to a null-terminated string containing a property line, or NULL. The output buffer is allocated by the library, and should be released by the caller using <tt>BCI_ReleaseObject()</tt>.
</dd></dl>
<a name="Online_Information"></a><h2>Online Information</h2>
<p>These functions allow to access information processed when the system is running. Modifying states and setting events will affect what is recorded in the data file.
</p>
<a name="int_BCI_SetStateValue.28_const_char.2A_stateName.2C_long_value_.29"></a><h3>int BCI_SetStateValue( const char* stateName, long value )</h3>
<p>Sets the value of a state to a given value. Setting a state via <tt>BCI_SetStateValue()</tt> may result in a change to BCI2000 system state.
</p>
<dl><dt>arguments</dt><dd> Pointer to a null-terminated state name string; new state value.
</dd><dt>returns</dt><dd>   1 if successful, 0 otherwise.
</dd></dl>
<a name="long_BCI_GetStateValue.28_const_char.2A_stateName_.29"></a><h3>long BCI_GetStateValue( const char* stateName )</h3>
<p>Returns the value of a state. <b>NOTE:</b> During operation, state values will only be updated when sent by the last module in the chain of core modules. This is governed by the <tt>OperatorBackLink</tt> parameter on the <tt>System</tt> tab, which must be set to 1.
</p>
<dl><dt>arguments</dt><dd> Pointer to a null-terminated state name string.
</dd><dt>returns</dt><dd>   State value, or 0 if the state does not exist.
</dd></dl>
<a name="int_BCI_SetEvent.28_const_char.2A_eventName.2C_long_value_.29"></a><h3>int BCI_SetEvent( const char* eventName, long value )</h3>
<p>Asynchronously sets the value of an event. In the data file, the point in time where SetEvent() was called will be associated with a single sample.
</p>
<dl><dt>arguments</dt><dd> Pointer to a null-terminated event name string; new event value.
</dd><dt>returns</dt><dd>   1 if successful, 0 otherwise.
</dd></dl>
<a name="int_BCI_GetSignalChannels.28.29"></a><h3>int BCI_GetSignalChannels()</h3>
<p>Returns the number of channels in the control signal.
</p>
<a name="int_BCI_GetSignalElements.28.29"></a><h3>int BCI_GetSignalElements()</h3>
<p>Returns the number of elements in the control signal.
</p>
<a name="float_BCI_GetSignal.28_int_channel.2C_int_element_.29"></a><h3>float BCI_GetSignal( int channel, int element )</h3>
<p>Returns a value from the control signal. <b>NOTE:</b> During operation, control signal values will only be updated when sent by the last module in the chain of core modules. This is governed by the <tt>OperatorBackLink</tt> parameter on the <tt>System</tt> tab, which must be set to 1.
</p>
<dl><dt>arguments</dt><dd> Channel index, element index (zero-based).
</dd><dt>returns</dt><dd>   Signal value.
</dd></dl>
<a name="Callbacks"></a><h2>Callbacks</h2>
<p>Whenever the Operator Library receives data, or its state is modified, a <i>callback event</i> is triggered. In response to this event, a callback function is called. Callback functions are registered with <tt>BCI_SetCallback()</tt> or <tt>BCI_SetExternalCallback()</tt>. The difference between the two registration functions is that the first registers a callback function to be called within the context of an internal thread of the Operator Library, while the second registers a callback function to be executed in a thread owned by the application that uses the Operator library, i.e. a thread that is "external" to the Operator library. That "external" thread needs to call <tt>BCI_CheckPendingCallback()</tt> regularly in order to execute callback functions. Typically, <tt>BCI_CheckPendingCallback()</tt> would be called from a GUI application's main thread within its message handling loop.
</p><p>Callback events are listed with their event names, and their handler's arguments. A callback function has at least one argument, which is a void* named refdata. The refdata pointer is supplied by user code when registering the callback function, and provided to the callback function unchanged. Typically, it would be used to store an object pointer in C++, or to an application specific data structure in C.
</p><p>In Windows, callbacks must follow the <i>stdcall</i> calling convention. In the Operator Library's header file, a macro STDCALL is provided that should be inserted after a callback function's return type in the function declaration. This macro allows setting the calling convention without confusing compilers when compiling for non-Windows systems.
</p><p>When programming in C++, callback functions must be either global functions, or functions declared "static" within class scope. They may not be ordinary member functions of a class. In object oriented programming however, you will typically want an ordinary member function to be called as a callback. This is possible using the "refdata" pointer to store an object pointer, and then call a member function on that object from the callback function as in the following example:
</p>
<pre>
class MyOperator
{
 public:
  MyOperator()
  {
    BCI_SetCallback( BCI_OnSystemStateChange, BCI_Function( &amp;OnSystemStateChangeCallback ), this );
  }
  ~MyOperator()
  {
    BCI_SetCallback( BCI_OnSystemStateChange, NULL, NULL );
  }
 private:
  void OnSystemStateChange()
  {
    ... // ordinary member function that gets executed when system state changes
  }
  static void STDCALL OnSystemStateChangeCallback( void* refdata )
  {
    MyOperator* pObject = reinterpret_cast&lt;MyOperator*&gt;( refdata );
    pObject-&gt;OnSystemStateChange();
  }
};
</pre>
<p>In the following, callbacks are listed as if they were ordinary functions. However, you will not use them this way. Rather, the "function name" is the name of the callback that is supplied as the first argument to <tt>BCI_SetCallback()</tt> or <tt>BCI_SetExternalCallback()</tt>. Your own callback function will have a different name, must return "void" or "int" as indicated, and must take the arguments listed as arguments to the callback. A pointer to your own callback function will then be specified as the second argument to <tt>BCI_SetCallback()</tt>, casted to the <tt>BCI_Function</tt> type.
</p>
<a name="Callback_Constants"></a><h3>Callback Constants</h3>
<dl><dt>BCI_Handled
</dt><dd>Return this constant to indicate that your callback handled the event. Only used with callback functions listed with an "int" return type.
</dd><dt>BCI_NotHandled
</dt><dd>Return this constant to indicate that your callback did not handle the event in question. Only used with callback functions listed with an "int" return type.
</dd></dl>
<a name="BCI_OnSystemStateChange.28_void.2A_refdata_.29"></a><h3> BCI_OnSystemStateChange( void* refdata )</h3>
<p>Occurs on any change to BCI2000 system state.
</p>
<a name="BCI_OnCoreInput.28_void.2A_refdata_.29"></a><h3>BCI_OnCoreInput( void* refdata )</h3>
<p>Occurs on input from any of the BCI2000 core modules.
</p>
<a name="BCI_OnConnect.28_void.2A_refdata_.29"></a><h3>BCI_OnConnect( void* refdata )</h3>
<p>Occurs when core modules have connected to the Operator Library.
</p>
<a name="BCI_OnSetConfig.28_void.2A_refdata_.29"></a><h3>BCI_OnSetConfig( void* refdata )</h3>
<p>Triggered when <tt>SetConfig()</tt> has been called.
</p>
<a name="BCI_OnStart.28_void.2A_refdata_.29"></a><h3>BCI_OnStart( void* refdata )</h3>
<p>Triggered when <tt>StartRun()</tt> has been called.
</p>
<a name="BCI_OnSuspend.28_void.2A_refdata_.29"></a><h3>BCI_OnSuspend( void* refdata )</h3>
<p>Triggered when BCI2000 goes into suspended state.
</p>
<a name="BCI_OnResume.28_void.2A_refdata_.29"></a><h3>BCI_OnResume( void* refdata )</h3>
<p>Triggered when BCI2000 enters the running state again.
</p>
<a name="BCI_OnShutdown.28_void.2A_refdata_.29"></a><h3>BCI_OnShutdown( void* refdata )</h3>
<p>Triggered when <tt>BCI_Shutdown()</tt> is called.
</p>
<a name="BCI_OnQuitRequest.28_void.2A_refdata.2C_const_char.2A.2A_pMsg_.29"></a><h3>BCI_OnQuitRequest( void* refdata, const char** pMsg )</h3>
<p>Triggered when a script executes the QUIT command. The application may choose to ignore the quit request, and should set the "message" pointer to a constant or static C string in this case. That string should provide information why the quit request was ignored.
</p>
<a name="BCI_OnLogMessage.28_void.2A_refdata.2C_const_char.2A_msg_.29"></a><h3>BCI_OnLogMessage( void* refdata, const char* msg )</h3>
<p>Triggered for each log message arriving from one of the modules, including the Operator module itself.
</p>
<a name="BCI_OnWarningMessage.28_void.2A_refdata.2C_const_char.2A_msg_.29"></a><h3>BCI_OnWarningMessage( void* refdata, const char* msg )</h3>
<p>Triggered for warning messages. Note that also a <tt>BCI_OnLogMessage</tt> event is triggered for warning messages.
</p>
<a name="BCI_OnErrorMessage.28_void.2A_refdata.2C_const_char.2A_msg_.29"></a><h3>BCI_OnErrorMessage( void* refdata, const char* msg )</h3>
<p>Triggered for error messages. Note that also a <tt>BCI_OnLogMessage</tt> event is triggered for error messages.
</p>
<a name="BCI_OnDebugMessage.28_void.2A_refdata.2C_const_char.2A_msg_.29"></a><h3>BCI_OnDebugMessage( void* refdata, const char* msg )</h3>
<p>Triggered for each <a href="Programming_Reference%253ADebug_Output.html" title="Programming Reference:Debug Output">debug message</a> received by the Operator module.
</p>
<a name="BCI_OnParameter.28_void.2A_refdata.2C_const_char.2A_parameterline_.29"></a><h3>BCI_OnParameter( void* refdata, const char* parameterline )</h3>
<p>Triggered whenever a parameter message arrives at the Operator module.
</p>
<a name="BCI_OnState.28_void.2A_refdata.2C_const_char.2A_stateline_.29"></a><h3>BCI_OnState( void* refdata, const char* stateline )</h3>
<p>Triggered whenever a state message arrives at the Operator module.
</p>
<a name="BCI_OnVisPropertyMessage.28_void.2A_refdata.2C_const_char.2A_visID.2C_int_cfgID.2C_const_char.2A_value_.29"></a><h3>BCI_OnVisPropertyMessage( void* refdata, const char* visID, int cfgID, const char* value )</h3>
<p>Triggered whenever a visproperty message arrives at the Operator module. For a list of available visualization properties, see <a href="Technical_Reference%253AVisualization_Properties.html" title="Technical Reference:Visualization Properties">Technical Reference:Visualization Properties</a>. Constants for the cfgID parameter are defined in the <tt>src/shared/types/CfgID.h</tt> header file.
</p>
<a name="BCI_OnVisProperty.28_void.2A_refdata.2C_const_char.2A_visID.2C_int_cfgID.2C_const_char.2A_value_.29"></a><h3>BCI_OnVisProperty( void* refdata, const char* visID, int cfgID, const char* value )</h3>
<p>Triggered when a visualization property is modified from a script. For a list of available visualization properties, see <a href="Technical_Reference%253AVisualization_Properties.html" title="Technical Reference:Visualization Properties">Technical Reference:Visualization Properties</a>. Constants for the cfgID parameter are defined in the <tt>src/shared/types/CfgID.h</tt> header file.
</p>
<a name="BCI_OnInitializeVis.28_void.2A_refdata.2C_const_char.2A_visID.2C_const_char.2A_kind_.29"></a><h3>BCI_OnInitializeVis( void* refdata, const char* visID, const char* kind )</h3>
<p>Triggered when the first data message for a visualization window arrives. The <tt>kind</tt> argument contains a string describing the kind of visualization required for; it is one of "Graph", "Memo", or "Bitmap".
</p>
<a name="BCI_OnVisMemo.28_void.2A_refdata.2C_const_char.2A_visID.2C_const_char.2A_msg_.29"></a><h3>BCI_OnVisMemo( void* refdata, const char* visID, const char* msg )</h3>
<p>Triggered for each memo data message to a visualization window. The <tt>visID</tt> argument specifies the window's visualization ID, the <tt>msg</tt> argument specifies the memo data.
</p>
<a name="BCI_OnVisSignal.28_void.2A_refdata.2C_const_char.2A_visID.2C_int_channels.2C_int_elements.2C_float.2A_data_.29"></a><h3>BCI_OnVisSignal( void* refdata, const char* visID, int channels, int elements, float* data )</h3>
<p>Triggered for each signal data message to a visualization window. Data are given such that the pair of indices <tt>(ch,el)</tt> corresponds to the single index <tt>ch*elements+el</tt>. Note that this is different from the layout of bitmap data.
</p>
<a name="BCI_OnVisBitmap.28_void.2A_refdata.2C_const_char.2A_visID.2C_int_width.2C_int_height.2C_unsigned_short.2A_data_.29"></a><h3>BCI_OnVisBitmap( void* refdata, const char* visID, int width, int height, unsigned short* data )</h3>
<p>Triggered for each bitmap data message to a visualization window. Data are given in ARGB 1444 format, where the 12 bits with lowest significance represent color. When any of the 3 bits with higher significance is set, the pixel is assumed to be transparent. Negative values are possible to allow for processing of difference images. In transmission, empty bitmaps (width and height set to 0) are sent to indicate that the next bitmap will be a reference frame; between reference frames, difference frames are sent.
</p><p>When addressing pixels, the pair of indices <tt>(x,y)</tt> corresponds to the single index <tt>y*width+x</tt>. Note that this is different from the layout of signal messages.
</p>
<a name="int_BCI_OnUnknownCommand.28_void.2A_refdata.2C_const_char.2A_command_.29"></a><h3>int BCI_OnUnknownCommand( void* refdata, const char* command )</h3>
<p>Triggered when the <a href="User_Reference%253AOperator_Module_Scripting.html" title="User Reference:Operator Module Scripting">Operator Module Scripting</a> engine meets an unknown command. The event handler can be used to extend the set of commands by handling those commands that are unknown to the scripting engine. To report that a command has been handled, return BCI_Handled from the callback function. Otherwise, return a value of BCI_NotHandled.
</p>
<a name="BCI_OnScriptHelp.28_void.2A_refdata.2C_const_char.2A.2A_pMsg_.29"></a><h3>BCI_OnScriptHelp( void* refdata, const char** pMsg )</h3>
<p>Triggered when the scripting engine's "Help" command is executed. Assign the address of a string constant to the memory location received in <tt>pMsg</tt>. The contents of the string will be printed last in the list of commands, preceded with "Application-defined commands: ".
</p>
<a name="BCI_OnScriptError.28_void.2A_refdata.2C_const_char.2A_msg_.29"></a><h3>BCI_OnScriptError( void* refdata, const char* msg )</h3>
<p>Triggered when script execution results in an error condition. Note that unknown commands are reported through the <tt>BCI_OnUnknownCommand</tt> event handler.
</p>
<a name="Functions_that_manage_callbacks"></a><h2>Functions that manage callbacks</h2>
<a name="int_BCI_SetCallback.28_long.2C_BCI_Function.2C_void.2A_.29"></a><h3>int BCI_SetCallback( long, BCI_Function, void* )</h3>
<p>Register a callback function. To clear a callback function, specify NULL as a function pointer.
</p>
<dl><dt>arguments</dt><dd> Event ID, callback function pointer, data pointer. The callback function pointer must be cast to the <tt>BCI_Function</tt> function pointer type. The data pointer may be any data that should be available to the callback function.
</dd><dt>returns</dt><dd>   1 if successful, 0 otherwise.
</dd></dl>
<a name="int_BCI_SetExternalCallback.28_long.2C_BCI_Function.2C_void.2A_.29"></a><h3>int BCI_SetExternalCallback( long, BCI_Function, void* )</h3>
<p>Register a callback function to be executed in an external thread on execution of <tt>BCI_CheckPendingCallback()</tt>. To clear a callback function, specify NULL as a function pointer.
</p>
<dl><dt>arguments</dt><dd> Event ID, callback function pointer, data pointer. The callback function pointer must be cast to the <tt>BCI_Function</tt> function pointer type. The data pointer may point to any data that should be available to the callback function.
</dd><dt>returns</dt><dd>   1 if successful, 0 otherwise.
</dd></dl>
<a name="int_BCI_CheckPendingCallback.28.29"></a><h3>int BCI_CheckPendingCallback()</h3>
<p>Call this function regularly from within an external thread you want external callbacks to run in. Typically, is is called from a GUI application's main event loop.
</p>
<dl><dt>arguments</dt><dd> None.
</dd><dt>returns</dt><dd>   1 if a callback was executed, 0 otherwise.
</dd></dl>
<a name="BCI_Function_BCI_GetCallbackFunction.28_long_.29"></a><h3>BCI_Function BCI_GetCallbackFunction( long )</h3>
<p>Get a registered callback function pointer.
</p>
<dl><dt>arguments</dt><dd> Event ID.
</dd><dt>returns</dt><dd>   Callback function pointer, or NULL if no callback function has been registered for the specified event.
</dd></dl>
<a name="void.2A_BCI_GetCallbackData.28_long_.29"></a><h3>void* BCI_GetCallbackData( long )</h3>
<p>Get registered callback data. Callback data is the first argument to callback functions, and specified when calling <tt>SetCallback()</tt> or <tt>SetExternalCallback()</tt>.
</p>
<dl><dt>arguments</dt><dd> Event ID.
</dd><dt>returns</dt><dd>   Callback data, or NULL if no callback data has been registered for the specified event.
</dd></dl>
<a name="int_BCI_GetCallbackIsExternal.28_long_.29"></a><h3>int BCI_GetCallbackIsExternal( long )</h3>
<p>Get information how callback was registered.
</p>
<dl><dt>arguments</dt><dd> Event ID.
</dd><dt>returns</dt><dd>   1 if the function was registered with <tt>BCI_SetExternalCallback()</tt>, and 0 if it was registered with <tt>BCI_SetCallback()</tt>, or when no callback was registered.
</dd></dl>
<a name="Miscellaneous_Functions"></a><h2>Miscellaneous Functions</h2>
<a name="const_char.2A_BCI_GetInfo.28_void_.29"></a><h3>const char* BCI_GetInfo( void )</h3>
<p>Reports build and source version information.
</p>
<dl><dt>arguments</dt><dd> None.
</dd><dt>returns</dt><dd>   Pointer to a null-terminated string holding the information requested. The output buffer is allocated by the library, and should be released by the caller using <tt>BCI_ReleaseObject()</tt>.
</dd></dl>
<a name="const_char.2A_BCI_GetConnectionInfo.28_int_index_.29"></a><h3>const char* BCI_GetConnectionInfo( int index )</h3>
<p>Obtains information about a <a href="Technical_Reference%253ACore_Modules.html" title="Technical Reference:Core Modules">core module</a> connection.
</p>
<dl><dt>argument</dt><dd>  Zero-based index of core module connection.
</dd><dt>returns</dt><dd>   Pointer to a null-terminated string containing connection information, or NULL for an invalid index. The output buffer is allocated by the library, and should be released by the caller using <tt>BCI_ReleaseObject()</tt>.
</dd></dl>
<a name="const_char.2A_BCI_GetCoreModuleStatus.28_int_index_.29"></a><h3>const char* BCI_GetCoreModuleStatus( int index )</h3>
<p>Obtains a <a href="Technical_Reference%253ACore_Modules.html" title="Technical Reference:Core Modules">core module's</a> current status message.
</p>
<dl><dt>argument</dt><dd>  Zero-based index of core module connection.
</dd><dt>returns</dt><dd>   Pointer to a null-terminated string containing status information, or NULL for an invalid index. The output buffer is allocated by the library, and should be released by the caller using <tt>BCI_ReleaseObject()</tt>.
</dd></dl>
<a name="int_BCI_Startup.28_const_char.2A_arguments_.29"></a><h3>int BCI_Startup( const char* arguments )</h3>
<p>Listens on core module connection ports.
</p>
<dl><dt>arguments</dt><dd> A string defining a local IP address (such as "localhost", or "134.2.123.151", or "*" to listen on all local addresses), and <a href="Technical_Reference%253ACore_Modules.html" title="Technical Reference:Core Modules">core module</a> names and listening ports in the form "&lt;name1&gt;:&lt;port1&gt; &lt;name2:port2&gt; ... &lt;nameN:portN&gt;" If NULL or empty, a value of "Source:4000 SignalProcessing:4001 Application:4002" representing a standard BCI2000 configuration is used, and the Operator module listens on all addresses.
</dd><dt>returns</dt><dd>   1 if successful, 0 otherwise.
</dd></dl>
<a name="int_BCI_Shutdown.28_void_.29"></a><h3>int BCI_Shutdown( void )</h3>
<p>Close connections to core modules, and go into idle state.
</p>
<dl><dt>returns</dt><dd>   1 if successful, 0 otherwise.
</dd></dl>
<a name="int_BCI_Initialize.28_void_.29"></a><h3> int BCI_Initialize( void )</h3>
<p>Initialize the library. Must be called before any other library function is used. This function should be called from your application's main thread.
</p>
<dl><dt>returns</dt><dd>   1 if no error occurred, 0 otherwise.
</dd></dl>
<a name="int_BCI_Dispose.28_void_.29"></a><h3> int BCI_Dispose( void )</h3>
<p>Dispose of all resources allocated by the library. This function must be called from the thread that called BCI_Initialize().
</p>
<dl><dt>returns</dt><dd>   1 if no error occurred, 0 otherwise.
</dd></dl>
<a name="int_BCI_TelnetListen.28_const_char.2A_address_.29"></a><h3> int BCI_TelnetListen( const char* address )</h3>
<p>Start a telnet server, listening at the given address. By opening a telnet connection, it is possible to execute <a href="User_Reference%253AOperator_Module_Scripting.html" title="User Reference:Operator Module Scripting">scripting commands</a> interactively.
</p>
<dl><dt>arguments</dt><dd> Address as a string in &lt;IP&gt;:&lt;port&gt; format. May be NULL, in which case it defaults to "localhost:3999".
</dd><dt>returns</dt><dd>   1 if no error occurred, 0 otherwise.
</dd></dl>
<a name="int_BCI_TelnetClose.28_void_.29"></a><h3> int BCI_TelnetClose( void )</h3>
<p>Stop the telnet server, closing any open connections.
</p>
<dl><dt>returns</dt><dd>   1 if no error occurred, 0 otherwise.
</dd></dl>
<a name="int_BCI_ExecuteScript.28_const_char.2A_script_.29"></a><h3>int BCI_ExecuteScript( const char* script )</h3>
<p>Interprets and executes the specified script according to the <a href="User_Reference%253AOperator_Module_Scripting.html" title="User Reference:Operator Module Scripting">Operator scripting reference</a>.
</p>
<dl><dt>arguments</dt><dd> Null-terminated string specifying script commands.
</dd><dt>returns</dt><dd>   0 if a syntax error is present, 1 otherwise.
</dd></dl>
<a name="const_char.2A_BCI_ExecuteScriptWithResult.28_const_char.2A_script_.29"></a><h3>const char* BCI_ExecuteScriptWithResult( const char* script )</h3>
<p>Interprets and executes the specified script according to the <a href="User_Reference%253AOperator_Module_Scripting.html" title="User Reference:Operator Module Scripting">Operator scripting reference</a>.
</p>
<dl><dt>arguments</dt><dd> Null-terminated string specifying script commands.
</dd><dt>returns</dt><dd>   NULL if a syntax error is present, pointer to a null-terminated result string otherwise. The result string is allocated by the library, and should be released by the caller using BCI_ReleaseObject(). The result is always identical to the result of the last executed script command.
</dd></dl>
<a name="int_BCI_ReleaseObject.28_const_char.2A_.29"></a><h3>int BCI_ReleaseObject( const char* )</h3>
<p>Indicate that an object that has been allocated by the library is no longer needed by the library's client.
</p>
<dl><dt>arguments</dt><dd> Object to be released, or NULL.
</dd><dt>returns</dt><dd>   1 if successful, 0 otherwise.
</dd></dl>
<a name="See_also"></a><h2>See also</h2>
<p><a href="User_Reference%253AOperator_Module_Scripting.html" title="User Reference:Operator Module Scripting">User Reference:Operator Module Scripting</a>, <a href="Technical_Reference%253AStates_of_Operation.html" title="Technical Reference:States of Operation">Technical Reference:States of Operation</a>, <a href="Programming_Reference%253ADebug_Output.html" title="Programming Reference:Debug Output">Programming Reference:Debug Output</a>
</p>
<div class="printfooter">
</div>

</div><br style="clear:both" />

<div id='footer'><table border="0" cellspacing="0"><tr><td width='152' rowspan='1'>&nbsp;</td><td class='bottom' align='left' valign='top'></td></tr></table>
</div>
</div>

<div id='quickbar'>
<table class="image"><caption align="bottom"><h2>BCI2000 Help</h2></caption><tr><td><a href="BCI2000_Help.html"><img src='../../images/bci2000logo_small.png' height=100 width=100 alt='[BCI2000 Help]' /></a></td></tr></table>
<hr class='sep' /><a href="User_Tutorial%253ABCI2000_Tour.html">Getting Started</a><br />
<a href="User_Reference%253AContents.html">User Manual</a><br />
<a href="Technical_Reference%253AContents.html">Technical Reference</a><br />
<ul><li><a href="Technical_Reference%253ASystem_Design.html">System Design</a></li>
<li><a href="Technical_Reference%253ACore_Modules.html">Core Modules</a></li>
<li><a href="Technical_Reference%253AStates_of_Operation.html">States of Operation</a></li>
<li><a href="Technical_Reference%253ABCI2000_Messages.html">BCI2000 Messages</a></li>
<li><a href="Technical_Reference%253AParameter_Definition.html">Parameter Definition</a></li>
<li><a href="Technical_Reference%253AState_Definition.html">State Definition</a></li>
</ul><a href="Programming_Reference%253AContents.html">Programming Manual</a><br />
<a href="Contributions%253AContents.html">Contributions</a><br />
<hr class='sep' />
<a href="BCI2000_Glossary.html">BCI2000 Glossary</a><br />
</div>

</body></html>